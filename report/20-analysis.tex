\chapter{Аналитический раздел}%
\label{cha:analiticheskii_razdel}

В данном разделе производится анализ предметной области, описываются различные подходы к решению поставленных задач. Также в этом разделе производится формализация задачи и дается описание требуемой функциональности разрабатываемого ПО.

\section{Руткиты}%
\label{sec:rutkity}

Руткит~--- это набор программных инструментов, позволяющих взломать информационную систему. Исторически термин Rootkit пришёл из UNIX, который означал некоторый набор утилит или специальный модуль ядра, который злоумышленник устанавливает на взломанной им компьютерной системе после получения прав суперпользователя. Рутикиты могут включать в себя разный функционал, например предоставление злоумышленнику прав суперпользователя, скрытие файлов и процессов, логирование действий пользователя и другое. Существует множество руткитов, которые реализованы под разные операционные системы. Рутикты могут работать как в пользовательском пространстве, так и в пространстве ядра.

\subsection{Виды руткитов}%
\label{sub:vidy_rutkitov}

Существует четыре основных видов руткитов.

\textbf{Руткиты пользовательского уровня}~--- это руткиты, которые работают на мои же уровне, что и обычные приложения, установленные и запускаемые пользователем. Чаще всего они перезаписывают функции определенных программ или динамических библиотек, которые загружают пользовательские приложения, чтобы исполнять неавторизованный вредоносный код. Считается, что рутикиты такого вида были одни из первых.

\textbf{Руткиты уровня ядра}~--- это руткиты, которые работают как драйверы или загружаемые модули ядра. Программное обеспечение, работающее на этом уровне, имеет прямой доступ к аппаратным и системным ресурсам. Руткиты этого уровня перезаписывают системные вызовы, что затрудняет их обнаружение.

\textbf{Буткиты}~--- это руткиты, которые записывают свой исполняемый код в основной загрузочный сектор жесткого диска. Благодаря этому они могут получить контроль над устройством ещё до запуска операционной системы. Являются разновидностью руткита уровня ядра.

\textbf{Аппаратные руткиты}~--- это программное обеспечение, которое скрыто внутри архитектуры компьютера, например в сетевой карте, жёстком диске или в системном BIOS.

\section{Загружаемый модуль ядра}%
\label{sec:zagruzhaemyi_modul_iadra}

Загружаемый модуль ядра~--- объектный файл, содержащий код, расширяющий возможности ядра операционной системы. Модули используются, чтобы добавить поддержку нового оборудования или файловых систем или для добавления новых системных вызовов. Когда функциональность, предоставляемая модулем, больше не требуется, он может быть выгружен, чтобы освободить память и другие ресурсы.

Основное преимущество и основная причина использования загружаемых модулей ядра заключается в том, что они могут расширять функциональные возможности ядра без необходимости перекомпилировать ядро или даже перезапускать систему. В системах Linux все модули обычно хранятся в каталоге /lib/modules и имеют расширение .ko. Модули загружаются и выгружаются службой modprobe. Основные команды для управления модулями: insmod (загрузка модулей), rmmod (удаление модулей) и lsmod.

Каждый загружаемый модуль ядра должен содержать в себе две ключевые функции: module\_init и module\_exit. Функция module\_init отвечает за выделение дополнительной памяти, необходимой для работы модуля (память для самого модуля выделяется ядром в пространстве памяти ядра), вызывая дополнительные потоки или процессы. Точно так же функция module\_exit отвечает за освобождение ранее выделенной памяти, остановку потоков или процессов и другие операции, необходимые для удаления модуля.

\section{Системные вызовы}%
\label{sec:sistemnye_vyzovy}

В программировании и вычислительной технике системный вызов является программным способом обращения компьютерной программы за определенной операцией от ядра операционной системы. Иными словами, системный вызов возникает, когда пользовательский процесс требует некоторой службы реализуемой ядром и вызывает специальную функцию.

Сюда могут входить услуги, связанные с аппаратным обеспечением (например, доступ к жесткому диску), создание и выполнение новых процессов, связь с интегральными службами ядра, такими как планирование процессов. Системные вызовы обеспечивают необходимый интерфейс между процессом и операционной системой.

\subsection{Промежуточная библиотека}%
\label{sub:promezhutochnaia_biblioteka}

Обычно, системы предоставляют библиотеку или API , которые находятся среди обычных программ и операционной системой. В Unix-подобных системах этот API обычно является частью реализации библиотеки С (libc), такой как glibc, которая обеспечивает функции –оболочки для системных вызовов, которые, в свою очередь, часто называются также, как и системные вызовы, которые они вызывают. В Windows NT этот API является частью Native API, в библиотеке ntdll.dll; Это недокументированный API, используемый реализациями обычного Windows API и непосредственно используется некоторыми системными программами в Windows. Функции-оболочки библиотеки предоставляют обычное соглашение о вызове функций (вызов подпрограммы на уровне сборки) для использования системного вызова, а также делают системный вызов более модульным. Здесь основной функцией-оболочки является помещение всех аргументов, которые должны быть переданы системному вызову в соответствующие регистры процессора (возможно, и в стек вызовов), а также установка уникального номера системного вызова для вызова ядра. Таким образом, библиотека, которая существует между ОС и приложением, увеличивает мобильность.

Вызов самой функции библиотеки не приводит к переключению в режим ядра (если исполнение уже не было в режиме ядра) и обычно является обычным вызовом подпрограммы. Фактический системный вызов передает управление ядру (и более зависит от конкретной реализации и платформы, чем библиотека вызова). Например, в Unix-подобных системах функции fork и execve являются функциями библиотеки С, которые, в свою очередь, выполняют инструкции, вызывающие системные вызовы fork и exec.

\section{Таблица системных вызовов}%
\label{sec:tablitsa_sistemnykh_vyzovov}

Таблица системных вызовов~--- это структура, которая хранит адреса исполняемого кода отдельных системных вызовов в области памяти ядра. По номеру системного вызова в таблица можно определить его адрес в памяти и вызвать его. Начиная с 2.6.x версии ядра linux, адрес таблица системных вызовов не экспортируется в syscalls.h, это сделано для затруднения доступа и редактирования таблицы системных вызовов.

Руткиты используют различные методы для получения адреса таблицы системных вызовов, чтобы иметь возможность редактировать или заменять ее.

\section{Анализ способов перехвата функций в ядре}%
\label{sec:analiz_sposobov_perekhvata_funktsii_v_iadre}

В рамках данного проекта необходимо осуществить перехват некоторых функций, то есть получение управления функции в момент её вызова.

Сегодня существует множество подходов для перехвата функций в ядре. Рассмотрим самые распространенные из них.

\subsection{Сплайсинг}%
\label{sub:splaising}

Сплайсинг~--- это классический метод перехвата функций, заключающийся в замене инструкций в начале функции на безусловный переход, ведущий в наш обработчик. Оригинальные инструкции переносятся в другое место и исполняются перед переходом обратно в перехваченную функцию. С помощью двух переходов мы вшиваем (splice in) свой дополнительный код в функцию, поэтому такой подход называется сплайсингом.

\subsection{Kprobes}%
\label{sub:kprobes}

Kprobes~--- это специализированное API, в первую очередь предназначенное для отладки и трассирования ядра. Этот интерфейс позволяет устанавливать пред- и постобработчики для любой инструкции в ядре, а также обработчики на вход и возврат из функции. Обработчики получают доступ к регистрам и могут их изменять. Таким образом, мы бы могли получить как мониторинг, так и возможность влиять на дальнейший ход работы.

\subsection{Модификация таблицы системных вызовов}%
\label{sub:modifikatsiia_tablitsy_sistemnykh_vyzovov}

Как известно, Linux хранит все обработчики системных вызовов в таблице sys\_call\_table. Подмена значений в этой таблице приводит к смене поведения всей системы. Таким образом, сохранив старое значения обработчика и подставив в таблицу собственный обработчик, мы можем перехватить любой системный вызов.

Алгоритм перехвата системных вызовов с помощью модификации таблицы системных вызовов следующий:
\begin{itemize}
    \item
        сохранить указатель на оригинальный (исходный) вызов для возможности его восстановления;
    \item
    создать функцию, реализующую новый системный вызов;
    \item
    в таблице системных вызовов sys\_call\_table произвести замену вызовов, т.е. настроить соответствующий указатель на новый системный вызов;
    \item
    по окончании работы (при выгрузке модуля) восстановить оригинальный системный вызов, используя ранее сохраненный указатель.
\end{itemize}

\section{Диагностика процессов}%
\label{sec:diagnostika_protsessov}

Для изучения операционной системы linux и используемых программ могут понадобиться средства диагностики процессов. В операционной системе linux есть утилиты, которые позволяют наблюдать системные вызовы, которые использует программа. Изучая системные вызовы, которые использует программа, можно узнать, к каким файлам обращается программа, какие сетевые порты она использует, какие ресурсы ей нужны, а также какие ошибки возвращает ей система.

Одной из таких утилит является strace. С помощью strace можно узнать, какие системные вызовы исполняет программа, а также их параметры и результат их выполнения.

В самом простом варианте strace запускает переданную команду с её аргументами и выводит в стандартный поток ошибок все системные вызовы команды.

\section{Выводы}%
\label{sec:vyvody}

В рамках данного проекта было принято решение использовать загружаемый модуль ядра для реализации руткита. Данный подход обеспечивает наименьшую вероятность обнаружения антивирусными программами. Также данный подход позволяет расширять функциональность руткита без необходимости перекомпилировать ядро.

Для подмены системных вызовов было принято решение использовать метод сплайсинг. Такое решение предоставляет возможность перехватывать не только системные вызовы, но и другие функции ядра, что может быть полезно.

Преимущество этого решения состоит в том, что таблица системных вызовов никоим образом не изменяется. Программы, используемые для обнаружения руткитов в системе очень часто сравнивают содержимое таблицы системных вызовов в памяти с содержимым, хранящимся в каталоге /boot. В случае использования выбранного решения они не обнаружат никаких различий и не вызовут тревогу.
